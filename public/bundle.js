/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 15);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7QUFDRCxT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QUFWLEVBQWU7QUFDM0IsVUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEO0FBR0FOLFFBQVEyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxXQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_vue__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__index_vue__);\n\n\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\n    el: '#app',\n    template: '<App/>',\n    components: { App: __WEBPACK_IMPORTED_MODULE_1__index_vue___default.a }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcz82YTRiIl0sIm5hbWVzIjpbImVsIiwidGVtcGxhdGUiLCJjb21wb25lbnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQSxJQUFJLG9EQUFKLENBQVE7QUFDSkEsUUFBSSxNQURBO0FBRUpDLGNBQVUsUUFGTjtBQUdKQyxnQkFBWSxFQUFFLHVEQUFGO0FBSFIsQ0FBUiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQXBwIGZyb20gJy4vaW5kZXgudnVlJ1xuXG5uZXcgVnVlKHtcbiAgICBlbDogJyNhcHAnLFxuICAgIHRlbXBsYXRlOiAnPEFwcC8+JyxcbiAgICBjb21wb25lbnRzOiB7IEFwcCB9XG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {var path = __webpack_require__(4);\nfunction resolve(dir) {\n    return path.join(__dirname, '..', dir);\n}\nmodule.exports = {\n    devtool: 'eval-source-map', //配置生成Source Maps，选择合适的选项\n    entry: __dirname + \"/app/main.js\", //已多次提及的唯一入口文件\n    output: {\n        path: __dirname + \"/public\", //打包后的文件存放的地方\n        filename: \"bundle.js\" //打包后输出文件的文件名\n    },\n    resolve: {\n        extensions: ['.js', '.vue', '.json'],\n        alias: {\n            'vue$': 'vue/dist/vue.esm.js',\n            '@': resolve('app')\n        }\n    },\n    module: {\n        rules: [{\n            test: /\\.vue$/,\n            loader: 'vue-loader'\n        }, {\n            test: /\\.js$/,\n            loader: 'babel-loader'\n        }, {\n            test: /\\.css$/,\n            loader: 'css-loader'\n        }]\n    }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, \"/\"))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93ZWJwYWNrLmNvbmZpZy5qcz83ZGNmIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwicmVzb2x2ZSIsImRpciIsImpvaW4iLCJfX2Rpcm5hbWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGV2dG9vbCIsImVudHJ5Iiwib3V0cHV0IiwiZmlsZW5hbWUiLCJleHRlbnNpb25zIiwiYWxpYXMiLCJydWxlcyIsInRlc3QiLCJsb2FkZXIiXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFJQSxPQUFPLG1CQUFBQyxDQUFRLENBQVIsQ0FBWDtBQUNBLFNBQVNDLE9BQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3JCLFdBQU9ILEtBQUtJLElBQUwsQ0FBVUMsU0FBVixFQUFxQixJQUFyQixFQUEyQkYsR0FBM0IsQ0FBUDtBQUNEO0FBQ0RHLE9BQU9DLE9BQVAsR0FBaUI7QUFDYkMsYUFBUyxpQkFESSxFQUNjO0FBQzNCQyxXQUFRSixZQUFZLGNBRlAsRUFFc0I7QUFDbkNLLFlBQVE7QUFDSlYsY0FBTUssWUFBWSxTQURkLEVBQ3dCO0FBQzVCTSxrQkFBVSxXQUZOLENBRWlCO0FBRmpCLEtBSEs7QUFPYlQsYUFBUztBQUNMVSxvQkFBWSxDQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLE9BQWhCLENBRFA7QUFFTEMsZUFBTztBQUNILG9CQUFRLHFCQURMO0FBRUgsaUJBQUtYLFFBQVEsS0FBUjtBQUZGO0FBRkYsS0FQSTtBQWNiSSxZQUFRO0FBQ0pRLGVBQU8sQ0FDSDtBQUNJQyxrQkFBTSxRQURWO0FBRUlDLG9CQUFRO0FBRlosU0FERyxFQUtIO0FBQ0lELGtCQUFNLE9BRFY7QUFFSUMsb0JBQVE7QUFGWixTQUxHLEVBU0g7QUFDSUQsa0JBQU0sUUFEVjtBQUVJQyxvQkFBUTtBQUZaLFNBVEc7QUFESDtBQWRLLENBQWpCLEMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5mdW5jdGlvbiByZXNvbHZlIChkaXIpIHtcbiAgcmV0dXJuIHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsIGRpcilcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRldnRvb2w6ICdldmFsLXNvdXJjZS1tYXAnLC8v6YWN572u55Sf5oiQU291cmNlIE1hcHPvvIzpgInmi6nlkIjpgILnmoTpgInpoblcbiAgICBlbnRyeTogIF9fZGlybmFtZSArIFwiL2FwcC9tYWluLmpzXCIsLy/lt7LlpJrmrKHmj5Dlj4rnmoTllK/kuIDlhaXlj6Pmlofku7ZcbiAgICBvdXRwdXQ6IHtcbiAgICAgICAgcGF0aDogX19kaXJuYW1lICsgXCIvcHVibGljXCIsLy/miZPljIXlkI7nmoTmlofku7blrZjmlL7nmoTlnLDmlrlcbiAgICAgICAgZmlsZW5hbWU6IFwiYnVuZGxlLmpzXCIvL+aJk+WMheWQjui+k+WHuuaWh+S7tueahOaWh+S7tuWQjVxuICAgIH0sXG4gICAgcmVzb2x2ZToge1xuICAgICAgICBleHRlbnNpb25zOiBbJy5qcycsICcudnVlJywgJy5qc29uJ10sXG4gICAgICAgIGFsaWFzOiB7XG4gICAgICAgICAgICAndnVlJCc6ICd2dWUvZGlzdC92dWUuZXNtLmpzJyxcbiAgICAgICAgICAgICdAJzogcmVzb2x2ZSgnYXBwJyksXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vZHVsZToge1xuICAgICAgICBydWxlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlc3Q6IC9cXC52dWUkLyxcbiAgICAgICAgICAgICAgICBsb2FkZXI6ICd2dWUtbG9hZGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXN0OiAvXFwuanMkLyxcbiAgICAgICAgICAgICAgICBsb2FkZXI6ICdiYWJlbC1sb2FkZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlc3Q6IC9cXC5jc3MkLyxcbiAgICAgICAgICAgICAgICBsb2FkZXI6ICdjc3MtbG9hZGVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vd2VicGFjay5jb25maWcuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290IiwiY29uY2F0Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQTtBQUNBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLFlBQVQsRUFBdUI7QUFDdkMsS0FBSUMsT0FBTyxFQUFYOztBQUVBO0FBQ0FBLE1BQUtDLFFBQUwsR0FBZ0IsU0FBU0EsUUFBVCxHQUFvQjtBQUNuQyxTQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO0FBQy9CLE9BQUlDLFVBQVVDLHVCQUF1QkYsSUFBdkIsRUFBNkJKLFlBQTdCLENBQWQ7QUFDQSxPQUFHSSxLQUFLLENBQUwsQ0FBSCxFQUFZO0FBQ1gsV0FBTyxZQUFZQSxLQUFLLENBQUwsQ0FBWixHQUFzQixHQUF0QixHQUE0QkMsT0FBNUIsR0FBc0MsR0FBN0M7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPQSxPQUFQO0FBQ0E7QUFDRCxHQVBNLEVBT0pFLElBUEksQ0FPQyxFQVBELENBQVA7QUFRQSxFQVREOztBQVdBO0FBQ0FOLE1BQUtPLENBQUwsR0FBUyxVQUFTQyxPQUFULEVBQWtCQyxVQUFsQixFQUE4QjtBQUN0QyxNQUFHLE9BQU9ELE9BQVAsS0FBbUIsUUFBdEIsRUFDQ0EsVUFBVSxDQUFDLENBQUMsSUFBRCxFQUFPQSxPQUFQLEVBQWdCLEVBQWhCLENBQUQsQ0FBVjtBQUNELE1BQUlFLHlCQUF5QixFQUE3QjtBQUNBLE9BQUksSUFBSUgsSUFBSSxDQUFaLEVBQWVBLElBQUksS0FBS0ksTUFBeEIsRUFBZ0NKLEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUlLLEtBQUssS0FBS0wsQ0FBTCxFQUFRLENBQVIsQ0FBVDtBQUNBLE9BQUcsT0FBT0ssRUFBUCxLQUFjLFFBQWpCLEVBQ0NGLHVCQUF1QkUsRUFBdkIsSUFBNkIsSUFBN0I7QUFDRDtBQUNELE9BQUlMLElBQUksQ0FBUixFQUFXQSxJQUFJQyxRQUFRRyxNQUF2QixFQUErQkosR0FBL0IsRUFBb0M7QUFDbkMsT0FBSUosT0FBT0ssUUFBUUQsQ0FBUixDQUFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFHLE9BQU9KLEtBQUssQ0FBTCxDQUFQLEtBQW1CLFFBQW5CLElBQStCLENBQUNPLHVCQUF1QlAsS0FBSyxDQUFMLENBQXZCLENBQW5DLEVBQW9FO0FBQ25FLFFBQUdNLGNBQWMsQ0FBQ04sS0FBSyxDQUFMLENBQWxCLEVBQTJCO0FBQzFCQSxVQUFLLENBQUwsSUFBVU0sVUFBVjtBQUNBLEtBRkQsTUFFTyxJQUFHQSxVQUFILEVBQWU7QUFDckJOLFVBQUssQ0FBTCxJQUFVLE1BQU1BLEtBQUssQ0FBTCxDQUFOLEdBQWdCLFNBQWhCLEdBQTRCTSxVQUE1QixHQUF5QyxHQUFuRDtBQUNBO0FBQ0RULFNBQUthLElBQUwsQ0FBVVYsSUFBVjtBQUNBO0FBQ0Q7QUFDRCxFQXhCRDtBQXlCQSxRQUFPSCxJQUFQO0FBQ0EsQ0ExQ0Q7O0FBNENBLFNBQVNLLHNCQUFULENBQWdDRixJQUFoQyxFQUFzQ0osWUFBdEMsRUFBb0Q7QUFDbkQsS0FBSUssVUFBVUQsS0FBSyxDQUFMLEtBQVcsRUFBekI7QUFDQSxLQUFJVyxhQUFhWCxLQUFLLENBQUwsQ0FBakI7QUFDQSxLQUFJLENBQUNXLFVBQUwsRUFBaUI7QUFDaEIsU0FBT1YsT0FBUDtBQUNBOztBQUVELEtBQUlMLGdCQUFnQixPQUFPZ0IsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtBQUMvQyxNQUFJQyxnQkFBZ0JDLFVBQVVILFVBQVYsQ0FBcEI7QUFDQSxNQUFJSSxhQUFhSixXQUFXSyxPQUFYLENBQW1CakIsR0FBbkIsQ0FBdUIsVUFBVWtCLE1BQVYsRUFBa0I7QUFDekQsVUFBTyxtQkFBbUJOLFdBQVdPLFVBQTlCLEdBQTJDRCxNQUEzQyxHQUFvRCxLQUEzRDtBQUNBLEdBRmdCLENBQWpCOztBQUlBLFNBQU8sQ0FBQ2hCLE9BQUQsRUFBVWtCLE1BQVYsQ0FBaUJKLFVBQWpCLEVBQTZCSSxNQUE3QixDQUFvQyxDQUFDTixhQUFELENBQXBDLEVBQXFEVixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0FBQ0E7O0FBRUQsUUFBTyxDQUFDRixPQUFELEVBQVVFLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDQTs7QUFFRDtBQUNBLFNBQVNXLFNBQVQsQ0FBbUJNLFNBQW5CLEVBQThCO0FBQzdCO0FBQ0EsS0FBSUMsU0FBU1QsS0FBS1UsU0FBU0MsbUJBQW1CQyxLQUFLQyxTQUFMLENBQWVMLFNBQWYsQ0FBbkIsQ0FBVCxDQUFMLENBQWI7QUFDQSxLQUFJTSxPQUFPLGlFQUFpRUwsTUFBNUU7O0FBRUEsUUFBTyxTQUFTSyxJQUFULEdBQWdCLEtBQXZCO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz84MDNhIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUFycmF5IiwicGFydHMiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwiaSIsImxlbmd0aCIsImxhc3QiLCJzcGxpY2UiLCJ1bnNoaWZ0Iiwic3BsaXRQYXRoUmUiLCJzcGxpdFBhdGgiLCJmaWxlbmFtZSIsImV4ZWMiLCJzbGljZSIsImV4cG9ydHMiLCJyZXNvbHZlIiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsImFyZ3VtZW50cyIsInBhdGgiLCJwcm9jZXNzIiwiY3dkIiwiVHlwZUVycm9yIiwiY2hhckF0IiwiZmlsdGVyIiwic3BsaXQiLCJwIiwiam9pbiIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJ0cmFpbGluZ1NsYXNoIiwic3Vic3RyIiwicGF0aHMiLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJpbmRleCIsInJlbGF0aXZlIiwiZnJvbSIsInRvIiwidHJpbSIsImFyciIsInN0YXJ0IiwiZW5kIiwiZnJvbVBhcnRzIiwidG9QYXJ0cyIsIk1hdGgiLCJtaW4iLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInB1c2giLCJjb25jYXQiLCJzZXAiLCJkZWxpbWl0ZXIiLCJkaXJuYW1lIiwicmVzdWx0Iiwicm9vdCIsImRpciIsImJhc2VuYW1lIiwiZXh0IiwiZiIsImV4dG5hbWUiLCJ4cyIsInJlcyIsInN0ciIsImxlbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLGNBQVQsQ0FBd0JDLEtBQXhCLEVBQStCQyxjQUEvQixFQUErQztBQUM3QztBQUNBLE1BQUlDLEtBQUssQ0FBVDtBQUNB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RUFBZ0JBLElBQUkwRCxHQUFHekQsTUFBdkIsRUFBK0JELEdBQS9CLEVBQW9DO0FBQ2hDLFFBQUl3RCxFQUFFRSxHQUFHMUQsQ0FBSCxDQUFGLEVBQVNBLENBQVQsRUFBWTBELEVBQVosQ0FBSixFQUFxQkMsSUFBSWIsSUFBSixDQUFTWSxHQUFHMUQsQ0FBSCxDQUFUO0FBQ3hCO0FBQ0QsU0FBTzJELEdBQVA7QUFDSDs7QUFFRDtBQUNBLElBQUloQyxTQUFTLEtBQUtBLE1BQUwsQ0FBWSxDQUFDLENBQWIsTUFBb0IsR0FBcEIsR0FDUCxVQUFVaUMsR0FBVixFQUFldEIsS0FBZixFQUFzQnVCLEdBQXRCLEVBQTJCO0FBQUUsU0FBT0QsSUFBSWpDLE1BQUosQ0FBV1csS0FBWCxFQUFrQnVCLEdBQWxCLENBQVA7QUFBK0IsQ0FEckQsR0FFUCxVQUFVRCxHQUFWLEVBQWV0QixLQUFmLEVBQXNCdUIsR0FBdEIsRUFBMkI7QUFDekIsTUFBSXZCLFFBQVEsQ0FBWixFQUFlQSxRQUFRc0IsSUFBSTNELE1BQUosR0FBYXFDLEtBQXJCO0FBQ2YsU0FBT3NCLElBQUlqQyxNQUFKLENBQVdXLEtBQVgsRUFBa0J1QixHQUFsQixDQUFQO0FBQ0gsQ0FMTCxDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'index',\n  data() {\n    return {\n      msg: 'Hello world!'\n    };\n  }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaW5kZXgudnVlP2Q2ZjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFPQTtRQUVBO1NBQ0E7O1dBR0E7QUFGQTtBQUdBO0FBTkEiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbjxkaXYgaWQ9XCJhcHBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZXhhbXBsZVwiPnt7IG1zZyB9fTwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaW5kZXgnLFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbXNnOiAnSGVsbG8gd29ybGQhJ1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5leGFtcGxlIHtcbiAgY29sb3I6IHJlZDtcbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaW5kZXgudnVlPzc1Y2RjYjBjIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n  return styles;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcz9lNmFjIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsImxpc3QiLCJzdHlsZXMiLCJuZXdTdHlsZXMiLCJpIiwibGVuZ3RoIiwiaXRlbSIsImlkIiwiY3NzIiwibWVkaWEiLCJzb3VyY2VNYXAiLCJwYXJ0IiwicHVzaCIsInBhcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBQSxPQUFPQyxPQUFQLEdBQWlCLFNBQVNDLFlBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDQyxJQUFqQyxFQUF1QztBQUN0RCxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxZQUFZLEVBQWhCO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILEtBQUtJLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNwQyxRQUFJRSxPQUFPTCxLQUFLRyxDQUFMLENBQVg7QUFDQSxRQUFJRyxLQUFLRCxLQUFLLENBQUwsQ0FBVDtBQUNBLFFBQUlFLE1BQU1GLEtBQUssQ0FBTCxDQUFWO0FBQ0EsUUFBSUcsUUFBUUgsS0FBSyxDQUFMLENBQVo7QUFDQSxRQUFJSSxZQUFZSixLQUFLLENBQUwsQ0FBaEI7QUFDQSxRQUFJSyxPQUFPO0FBQ1RKLFVBQUlQLFdBQVcsR0FBWCxHQUFpQkksQ0FEWjtBQUVUSSxXQUFLQSxHQUZJO0FBR1RDLGFBQU9BLEtBSEU7QUFJVEMsaUJBQVdBO0FBSkYsS0FBWDtBQU1BLFFBQUksQ0FBQ1AsVUFBVUksRUFBVixDQUFMLEVBQW9CO0FBQ2xCTCxhQUFPVSxJQUFQLENBQVlULFVBQVVJLEVBQVYsSUFBZ0IsRUFBRUEsSUFBSUEsRUFBTixFQUFVTSxPQUFPLENBQUNGLElBQUQsQ0FBakIsRUFBNUI7QUFDRCxLQUZELE1BRU87QUFDTFIsZ0JBQVVJLEVBQVYsRUFBY00sS0FBZCxDQUFvQkQsSUFBcEIsQ0FBeUJELElBQXpCO0FBQ0Q7QUFDRjtBQUNELFNBQU9ULE1BQVA7QUFDRCxDQXRCRCIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.3.3\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Perform no operation.\n */\nfunction noop() {}\n\n/**\n * Always return false.\n */\nvar no = function () {\n  return false;\n};\n\n/**\n * Return same value\n */\nvar identity = function (_) {\n  return _;\n};\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n      // possible circular reference\n      return a === b;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = null; // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n      if (n > 1) {\n        str += str;\n      }\n      n >>= 1;\n    }\n    return res;\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n\n/*  */\n\nfunction handleError(err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer;\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) {\n      console.error(err);\n    };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      });\n    }\n  };\n}();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) {\n    targetStack.push(Dep.target);\n  }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) {\n      ob.observeArray(inserted);\n    }\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, asRootData) {\n  if (!isObject(value)) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1(obj, key, val, customSetter) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n  if (!hasOwn(target, key)) {\n    return;\n  }\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n    return defaultStrat(parent, child);\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook(parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, childVal) : res;\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options) {\n  var props = options.props;\n  if (!props) {\n    return;\n  }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\n/*  */\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n  if (value == null && !prop.required) {\n    return;\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n    return;\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isType(type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type);\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true;\n    }\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function (tag) {\n      return perf.mark(tag);\n    };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed;\n    }\n  };\n\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned;\n}\n\nfunction cloneVNodes(vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res;\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns) {\n  function invoker() {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments);\n    }\n  }\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return;\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n  return children;\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res;\n}\n\n/*  */\n\nfunction ensureCtor(comp, base) {\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, context) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(process.env.NODE_ENV !== 'production' ? \"timeout (\" + res.timeout + \"ms)\" : null);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c;\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm;\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm;\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm;\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n  var slots = {};\n  if (!children) {\n    return slots;\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n      var name = child.data.slot;\n      var slot = slots[name] || (slots[name] = []);\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle(vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n      , vm.$options._parentElm, vm.$options._refElm);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure(name + \" render\", startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure(name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  parentVnode.data.scopedSlots || // has new scoped slots\n  vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, hook + \" hook\");\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks(queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n  this.value = this.lazy ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown() {\n  var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse(val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if (!isA && !isObject(val) || !Object.isExtensible(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n  if (opts.watch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function (key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop(key);\n  observerState.shouldConvert = true;\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\"The data property \\\"\" + keys[i] + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData(data, vm) {\n  try {\n    return data.call(vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed(vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\", vm);\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data;\n  };\n  var propsDef = {};\n  propsDef.get = function () {\n    return this._props;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\n/*  */\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n        source = source.$parent;\n      }\n    }\n    return result;\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) {\n    return createElement(_context, a, b, c, d, true);\n  };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () {\n      return resolveSlots(children, context);\n    }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating, parentElm, refElm) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n    return;\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return;\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent, // activeInstance in lifecycle state\nparentElm, refElm) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options);\n}\n\nfunction mergeHooks(data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1(one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  };\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) {\n      applyNS(vnode, ns);\n    }\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    ret._isVList = true;\n  }\n  return ret;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1;\n  } else {\n    return keyCodes !== eventKeyCode;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  };\n}\n\nfunction renderMixin(Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified;\n}\n\nfunction dedupe(latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res;\n  } else {\n    return latest;\n  }\n}\n\nfunction Vue$3(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n}\n\n/*  */\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n      }\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction pruneCache(cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created() {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return matches(val, name);\n      });\n    },\n    exclude: function exclude(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return !matches(val, name);\n      });\n    }\n  },\n\n  render: function render() {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n        return vnode;\n      }\n      var key = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode;\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () {\n    return config;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext;\n  }\n});\n\nVue$3.version = '2.3.3';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false;\n};\n\n/*  */\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction genClassFromData(data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (isUndef(value)) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1);\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) {\n        res += key + ' ';\n      }\n    }\n    return res.slice(0, -1);\n  }\n  /* istanbul ignore next */\n  return res;\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function (tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n  if (isReservedTag(tag)) {\n    return false;\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n    return selected;\n  } else {\n    return el;\n  }\n}\n\n/*  */\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm;\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute(node, key, val) {\n  node.setAttribute(key, val);\n}\n\nvar nodeOps = Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope(vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate(elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false;\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true /* hydrating */);\n      }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break;\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false;\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(vnode, insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res;\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x60:\n          inTemplateString = true;break; // `\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0;\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') {\n            break;\n          }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n  }\n}\n\n/*  */\n\nfunction baseWarn(msg) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr(el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective(el, name, rawName, value, arg, modifiers) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n}\n\nfunction getAndRemoveAttr(el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return val;\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: \"\\\"\" + value + \"\\\"\",\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"var $$exp = \" + modelRs.exp + \", $$idx = \" + modelRs.idx + \";\" + \"if (!Array.isArray($$exp)){\" + value + \"=\" + assignment + \"}\" + \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\";\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel(val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    };\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n  }\n\n  // ensure runtime directive metadata\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1(event, handler, once$$1, capture, passive) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n}\n\nfunction remove$2(event, handler, capture, _target) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n      if (cur === oldProps[key]) {\n        continue;\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, vnode, checkVal) {\n  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n}\n\nfunction isDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal;\n}\n\nfunction isInputChanged(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal);\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim();\n  }\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n  return bindingStyle;\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && prop in testEl.style) {\n    return prop;\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) {\n    return cb();\n  }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n}\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1)) * 1000;\n}\n\n/*  */\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return;\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm();\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple ? binding.value.some(function (v) {\n        return hasNoMatchingOption(v, el.options);\n      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return;\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) {\n      return;\n    }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return;\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) {\n      return c.tag;\n    });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return;\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) {\n      return d.name === 'show';\n    })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () {\n          delayedLeave();\n        };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  beforeUpdate: function beforeUpdate() {\n    // force removing pass\n    this.__patch__(this._vnode, this.kept, false, // hydrating\n    true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      if (this._hasMove != null) {\n        return this._hasMove;\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode(content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0;\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n/*  */\n\nvar decoder;\n\nfunction decode(html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent;\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n// attr value double quotes\n/\"([^\"]*)\"+/.source,\n// attr value, single quotes\n/'([^']*)'+/.source,\n// attr value, no quotes\n/([^\\s\"'=<>`]+)/.source];\nvar attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest$1 = void 0,\n          next = void 0;\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return '';\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n      }\n      break;\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') {\n          delete args[3];\n        }\n        if (args[4] === '') {\n          delete args[4];\n        }\n        if (args[5] === '') {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, options.shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+');\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre(element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start(tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints(el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) {\n          // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end() {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars(text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.');\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n          }\n        }\n        return;\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n      // only preserve whitespace if its not right after a starting tag\n      : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n      return;\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map;\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks(conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false;\n    }\n    if (node.for) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative, warn) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n      warn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n    }\n    res += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n  }\n  return res.slice(0, -1) + '}';\n}\n\nfunction genHandler(name, handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(name, handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n  var alias = keyCodes[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n}\n\n/*  */\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\";\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate(ast, options) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: currentStaticRenderFns\n  };\n}\n\nfunction genElement(el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el);\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el);\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code;\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic(el) {\n  el.staticProcessed = true;\n  staticRenderFns.push(\"with(this){return \" + genElement(el) + \"}\");\n  return \"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n}\n\n// v-once\nfunction genOnce(el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\"v-once can only be used inside v-for that is keyed. \");\n      return genElement(el);\n    }\n    return \"_o(\" + genElement(el) + \",\" + onceCount++ + (key ? \",\" + key : \"\") + \")\";\n  } else {\n    return genStatic(el);\n  }\n}\n\nfunction genIf(el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice());\n}\n\nfunction genIfConditions(conditions) {\n  if (!conditions.length) {\n    return '_e()';\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp(el) {\n    return el.once ? genOnce(el) : genElement(el);\n  }\n}\n\nfunction genFor(el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    warn$3(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genElement(el) + '})';\n}\n\nfunction genData(el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) {\n    data += dirs + ',';\n  }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + genProps(el.props) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += genHandlers(el.events, false, warn$3) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true, warn$3) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += genScopedSlots(el.scopedSlots) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data;\n}\n\nfunction genDirectives(el) {\n  var dirs = el.directives;\n  if (!dirs) {\n    return;\n  }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(slots) {\n  return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n    return genScopedSlot(key, slots[key]);\n  }).join(',') + \"])\";\n}\n\nfunction genScopedSlot(key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el);\n  }\n  return \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + \"}}\";\n}\n\nfunction genForScopedSlot(key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el) + '})';\n}\n\nfunction genChildren(el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      return genElement(el$1);\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return \"[\" + children.map(genNode).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue;\n    }\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction maybeComponent(el) {\n  return !isPlatformReservedTag$1(el.tag);\n}\n\nfunction genNode(node) {\n  if (node.type === 1) {\n    return genElement(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genSlot(el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n    return camelize(a.name) + \":\" + a.value;\n  }).join(',') + \"}\";\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')';\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return \"_c(\" + componentName + \",\" + genData(el) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n  }\n  return res.slice(0, -1);\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors(ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors;\n}\n\nfunction checkNode(node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent(exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor(node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier(ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n  }\n}\n\nfunction checkExpression(exp, text, errors) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    } else {\n      errors.push(\"invalid expression: \" + text.trim());\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n}\n\nfunction makeFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop;\n  }\n}\n\nfunction createCompiler(baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile(template, options) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled;\n  }\n\n  function compileToFunctions(template, options, vm) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key];\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n          return \"- \" + e;\n        }).join('\\n') + '\\n', vm);\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) {\n          return tip(msg, vm);\n        });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return functionCompileCache[key] = res;\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  };\n}\n\n/*  */\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2(el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [klass$1, style$1];\n\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n  }\n}\n\n/*  */\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating);\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(8)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanM/NjVkNyJdLCJuYW1lcyI6WyJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImNhbGwiLCJpc1JlZ0V4cCIsInZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJ0b051bWJlciIsIm4iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm1hcCIsImNyZWF0ZSIsImxpc3QiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInNsaWNlIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJiaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiQXJyYXkiLCJleHRlbmQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJyZXMiLCJub29wIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJiIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiZSIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2xpZmVjeWNsZUhvb2tzIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsIndhcm4iLCJ0aXAiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsImVycm9yIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJuYW1lIiwib3B0aW9ucyIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsImNvbnN0cnVjdG9yIiwicHVzaCIsImlzQXJyYXkiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJpbkJyb3dzZXIiLCJoYXNQcm90byIsIndpbmRvdyIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwibmV4dFRpY2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwibG9nRXJyb3IiLCJ0aGVuIiwiY2F0Y2giLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiZGF0YSIsInF1ZXVlTmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwicmVqZWN0IiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwidWlkIiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJhcmdzIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsImlzU2V0dGluZ1Byb3BzIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiaXRlbXMiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwiTWF0aCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwicGFyZW50IiwiY2hpbGQiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwidHlwZSIsIndhdGNoIiwicHJvcHMiLCJtZXRob2RzIiwiY29tcHV0ZWQiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJpc1R5cGUiLCJCb29sZWFuIiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRDb252ZXJ0IiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsImxlbiIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwidGFnIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJWTm9kZSIsImNoaWxkcmVuIiwidGV4dCIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwibnMiLCJmdW5jdGlvbmFsQ29udGV4dCIsImNvbXBvbmVudEluc3RhbmNlIiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImRlZmluZVByb3BlcnRpZXMiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNhcHR1cmUiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsImV2ZW50IiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiZmFjdG9yeSIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImV2ZXJ5IiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCIkc2xvdHMiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwicXVldWUiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwic29ydCIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicmVmIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImhhbmRsZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImluamVjdCIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsIl9jb250ZXh0IiwiaCIsImQiLCJjcmVhdGVFbGVtZW50IiwiaW5qZWN0aW9ucyIsImZ1bmN0aW9uYWxPcHRpb25zIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBseU5TIiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImRvbVByb3BzIiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiaW5pdFJlbmRlciIsInJlbmRlckNvbnRleHQiLCJfYyIsIiRjcmVhdGVFbGVtZW50IiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJ1aWQkMSIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWQiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsIlJlZ0V4cCIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJjdXJyZW50IiwiZmlsdGVyIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwiZ2VuQ2xhc3NGcm9tRGF0YSIsInN0YXRpY0NsYXNzIiwiY2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJob29rcyIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaW5QcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiYWRkQXR0ciIsImFkZERpcmVjdGl2ZSIsImFyZyIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwibmV4dCIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsInN1YnN0cmluZyIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZHluYW1pY1R5cGUiLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwidGFyZ2V0JDEiLCJhZGQkMSIsIm9sZEhhbmRsZXIiLCJldiIsInJlbW92ZSQyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInByZWZpeGVzIiwidGVzdEVsIiwidXBwZXIiLCJwcmVmaXhlZCIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiZGVmJCQxIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwibmVlZFJlc2V0Iiwic29tZSIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwib3B0aW9uIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJrZXkkMSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsImJvZHkiLCJmIiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwic2hvdWxkRGVjb2RlIiwiY29udGVudCIsImVuY29kZWQiLCJkaXYiLCJpbm5lckhUTUwiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImRlY29kZXIiLCJkZWNvZGUiLCJodG1sIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImRlY29kZUF0dHIiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QkMSIsImNoYXJzIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsImVuZFRhZ0xlbmd0aCIsInJlc3QiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsImV4ZWMiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJndWFyZElFU1ZHQnVnIiwibWFrZUF0dHJzTWFwIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0tleSIsInBsYWluIiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwiaSQyIiwibGFzdE5vZGUiLCJpc1RleHRUYWciLCJjaGVja0luRm9yIiwiaW5NYXRjaCIsImZvciIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290Iiwid2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIiwiY29uZGl0aW9uQmxvY2tzIiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsInJpZ2h0IiwiZG93biIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInNlbGYiLCJjdHJsIiwic2hpZnQiLCJhbHQiLCJtZXRhIiwibWlkZGxlIiwiZ2VuSGFuZGxlcnMiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Nb2RpZmllckNvZGUiLCJnZW5LZXlGaWx0ZXIiLCJoYW5kbGVyQ29kZSIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJwYXJzZUludCIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIndhcm4kMyIsInRyYW5zZm9ybXMkMSIsImRhdGFHZW5GbnMiLCJwbGF0Zm9ybURpcmVjdGl2ZXMkMSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxIiwib25jZUNvdW50IiwiY3VycmVudE9wdGlvbnMiLCJnZW5lcmF0ZSIsImFzdCIsInByZXZTdGF0aWNSZW5kZXJGbnMiLCJjdXJyZW50U3RhdGljUmVuZGVyRm5zIiwicHJldk9uY2VDb3VudCIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhIiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJtYXliZUNvbXBvbmVudCIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsInNjb3BlIiwiY2hlY2tTa2lwIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwiaWRlbnRSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJGdW5jdGlvbiIsImJhc2VDb21waWxlIiwibWFrZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZXIiLCJiYXNlT3B0aW9ucyIsImZ1bmN0aW9uQ29tcGlsZUNhY2hlIiwiY29tcGlsZSIsImZpbmFsT3B0aW9ucyIsInRpcHMiLCJ0aXAkJDEiLCJjb21waWxlZCIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsImZuR2VuRXJyb3JzIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEkMSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDIiLCJzdHlsZSQxIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwicmVmJDEiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBLFNBQVNBLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLE1BQU1DLFNBQU4sSUFBbUJELE1BQU0sSUFBaEM7QUFDRDs7QUFFRCxTQUFTRSxLQUFULENBQWdCRixDQUFoQixFQUFtQjtB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QU0wdUIsT0FBTixHQUFnQkssa0JBQWhCOztBQUVBLHlEQUFlL3VCLEtBQWYsRSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuMy4zXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSApKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIG5vZGVzIChwcmV2ZW50cyBsZWFrKVxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0ge1xuICBrZXk6IDEsXG4gIHJlZjogMSxcbiAgc2xvdDogMVxufTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0gfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICAgIGdldHRlciA9IG5vb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMSsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMy4zJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKGlzVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICB2YXIgcmVzID0gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHZhbHVlW2ldKSkge1xuICAgICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICBpZiAocmVmLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAhYmFpbGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm5cbikge1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKGVsLCBuYW1lKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInZhciAkJGV4cCA9IFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCAkJGlkeCA9IFwiICsgKG1vZGVsUnMuaWR4KSArIFwiO1wiICtcbiAgICAgIFwiaWYgKCFBcnJheS5pc0FycmF5KCQkZXhwKSl7XCIgK1xuICAgICAgICB2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudCArIFwifVwiICtcbiAgICAgIFwiZWxzZXskJGV4cC5zcGxpY2UoJCRpZHgsIDEsIFwiICsgYXNzaWdubWVudCArIFwiKX1cIlxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkYyl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2xleSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkQ2hpbGQgJiYgb2xkQ2hpbGQuZGF0YSAmJiAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIj5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxufVxuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+Lz1dKykvO1xudmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xudmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5dO1xudmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG4gICdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG4gICcoPzpcXFxccyooJyArIHNpbmdsZUF0dHJBc3NpZ24uc291cmNlICsgJyknICtcbiAgJ1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG4pO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbidcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCQxID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCQxKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0JDEuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3Q7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgdGFnTmFtZSA9PT0gJ2h0bWwnICYmIGxhc3RUYWcgPT09ICdoZWFkJyB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5qb2luKCcrJylcbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHNbbmFtZV07XG4gICAgLy8gIzUzMzA6IHdhcm4gY2xpY2sucmlnaHQsIHNpbmNlIHJpZ2h0IGNsaWNrcyBkbyBub3QgYWN0dWFsbHkgZmlyZSBjbGljayBldmVudHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG5hbWUgPT09ICdjbGljaycgJiZcbiAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5tb2RpZmllcnMgJiYgaGFuZGxlci5tb2RpZmllcnMucmlnaHRcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVXNlIFxcXCJjb250ZXh0bWVudVxcXCIgaW5zdGVhZCBvZiBcXFwiY2xpY2sucmlnaHRcXFwiIHNpbmNlIHJpZ2h0IGNsaWNrcyBcIiArXG4gICAgICAgIFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMztcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMyA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG4gICkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHdhcm4kMykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgd2FybiQzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMyk7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICB3YXJuJDMoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0pOyB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChrZXksIGVsKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwpXG4gIH1cbiAgcmV0dXJuIFwie2tleTpcIiArIGtleSArIFwiLGZuOmZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwpKSArIFwifX1cIlxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChrZXksIGVsKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlblNjb3BlZFNsb3Qoa2V5LCBlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChlbCwgY2hlY2tTa2lwKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsJDEpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcCA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuKSA6IDA7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZ2VuTm9kZSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoY2hpbGRyZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIG1heWJlQ29tcG9uZW50IChlbCkge1xuICByZXR1cm4gIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxKGVsLnRhZylcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKGNvbXBvbmVudE5hbWUsIGVsKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEoZWwpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG52YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvbkNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0aXBzID0gW107XG4gICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXAkJDEpIHtcbiAgICAgICh0aXAkJDEgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgIH1cbiAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgcmV0dXJuIGNvbXBpbGVkXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICB2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0sIGZuR2VuRXJyb3JzKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldID0gcmVzKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBjb21waWxlLFxuICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY29tcGlsZVRvRnVuY3Rpb25zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQyXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBS0MsU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFFQyxJQUFILEVBQVMsTUFBVCxDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFNQyxDQUFOLEVBQVM7QUFDVjtBQUNBLEtBQUcsT0FBT0MsTUFBUCxLQUFrQixRQUFyQixFQUNDSixJQUFJSSxNQUFKO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCTixDQUFqQiIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(3)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.example {\\n  color: red;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/Users/kaiwen/project/webpack-demo/app/index.vue?75cdcb0c\"],\"names\":[],\"mappings\":\";AAkBA;EACA,WAAA;CACA\",\"file\":\"index.vue\",\"sourcesContent\":[\"<template>\\n<div id=\\\"app\\\">\\n    <div class=\\\"example\\\">{{ msg }}</div>\\n</div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'index',\\n  data () {\\n    return {\\n      msg: 'Hello world!'\\n    }\\n  }\\n}\\n</script>\\n\\n<style>\\n.example {\\n  color: red;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvaW5kZXgudnVlPzZmNGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBc0MsZUFBZSxHQUFHLFVBQVUsNEdBQTRHLE1BQU0sVUFBVSx1R0FBdUcsT0FBTyx5REFBeUQsK0JBQStCLGNBQWMsa0NBQWtDLEtBQUssR0FBRyxrQ0FBa0MsZUFBZSxHQUFHLCtCQUErQjs7QUFFL2dCIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmV4YW1wbGUge1xcbiAgY29sb3I6IHJlZDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9rYWl3ZW4vcHJvamVjdC93ZWJwYWNrLWRlbW8vYXBwL2luZGV4LnZ1ZT83NWNkY2IwY1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBa0JBO0VBQ0EsV0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJpbmRleC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbjxkaXYgaWQ9XFxcImFwcFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImV4YW1wbGVcXFwiPnt7IG1zZyB9fTwvZGl2PlxcbjwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBuYW1lOiAnaW5kZXgnLFxcbiAgZGF0YSAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgbXNnOiAnSGVsbG8gd29ybGQhJ1xcbiAgICB9XFxuICB9XFxufVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4uZXhhbXBsZSB7XFxuICBjb2xvcjogcmVkO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTUwOWI3YmE2XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FwcC9pbmRleC52dWVcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(13)\n}\nvar Component = __webpack_require__(11)(\n  /* script */\n  __webpack_require__(5),\n  /* template */\n  __webpack_require__(12),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"/Users/kaiwen/project/webpack-demo/app/index.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] index.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-509b7ba6\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-509b7ba6\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvaW5kZXgudnVlPzRmYWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0Esd0JBQTJMO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTUwOWI3YmE2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNTA5YjdiYTZcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaW5kZXgudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL2thaXdlbi9wcm9qZWN0L3dlYnBhY2stZGVtby9hcHAvaW5kZXgudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBpbmRleC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNTA5YjdiYTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi01MDliN2JhNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2luZGV4LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('div', {\n    staticClass: \"example\"\n  }, [_vm._v(_vm._s(_vm.msg))])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-509b7ba6\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvaW5kZXgudnVlPzdhY2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImFwcFwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJleGFtcGxlXCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLm1zZykpXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01MDliN2JhNlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTUwOWI3YmE2XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hcHAvaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(14)(\"346c4fde\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-509b7ba6\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue\", function() {\n     var newContent = require(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-509b7ba6\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvaW5kZXgudnVlP2ZhNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxtQ0FBa047QUFDbE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCxtRkFBbUY7QUFDak4sdUlBQXVJLG1GQUFtRjtBQUMxTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTUwOWI3YmE2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjM0NmM0ZmRlXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTUwOWI3YmE2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNTA5YjdiYTZcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi01MDliN2JhNlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9hcHAvaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(6)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz82YjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(2);


/***/ })
/******/ ]);